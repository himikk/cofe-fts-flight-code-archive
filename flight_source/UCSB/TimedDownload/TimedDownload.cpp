// TimedDownload.cpp : Defines the entry point for the console application.
//
// This was generated by Russell Woods
// 
// Original Compiler
// Microsoft Visual Studio 2008
// Version 9.0.21022.8 RTM
// 
// Compilation options set to use the statically linked library
// No additional DLL support should be needed (for example, no CRT DLL)
// Expected compatibility with all Windows 2000 + OS versions
//
//  The purpose of this code is to do timed downloads of jpg files
//  To support other file types one merely needs to change the TimeToSubDirectoryAndFilename function
//
//
//  This expects a configuration file called configuration.cfg to be in the same directory
//  if an alternately named file is desired, it can be passed as an argument on the command line
//  [need to insert the text of configuration.cfg here to ensure its transmission]
//
//  Passing /? to the command line will display an embedded config file with full documentation
//



#include "stdafx.h"

#include "timedDownload.h"
#include "InternalTime.h"
#include "ConfigFileReader.h"
#include "flir-capture.h"

using std::for_each;
using std::string;
using std::wstring;
using std::vector;
using std::map;
using namespace InternalTime;
using UCSBUtility::StupidConvertToWString;
using ConfigFileReader::ConvertBufferToLines;
using ConfigFileReader::ConvertLineToFields;

// Constants
const DWORD  maxSleepTime = 1000;

// Global signaling variable
// when this is true, the program exits
static bool quit = false;
static bool displayQueue = false;

// Function to print elements to stderr for debugging purposes
void PrintPriorityQueueElement(priorityQueue::value_type const& pqElement)
{
    UINT64 time = pqElement.first;
    queuedFile const& qf = pqElement.second;

    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Server      : %ls\n", qf.sourceServer.c_str());
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Resource    : %ls\n", qf.sourceResource.c_str());
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "destination : %ls\n", qf.destinationRootName.c_str());
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Next time   : %I64d\n", time / oneSecond);
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "startTime   : %I64d\n", qf.startTime / oneSecond);
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "interval    : %I64d\n", qf.downloadInterval / oneSecond);
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "\n");
}


// This is the heart of the download code
// (that's separate from the priority queue, which is the heart of
//  the timing mechanism)
// This simply does what it claims
// Reads a file from the web given an existing internet connection and
// source and destination names
int ReadWebFile(HINTERNET iNetConnection, 
                wstring const& sourceName, 
                wstring const& destinationName)
{
    InternetHandle hURL = HttpOpenRequest(iNetConnection,
        L"POST",                  // GET or POST
        sourceName.c_str(),       // root "/" by default
        NULL,                     // Use default HTTP/1.1 as the version
        NULL,                     // Do not provide any referrer
        NULL,                     // Do not provide Accept types
        0,
        NULL);

    if (hURL == NULL)
    {
        //Error = GetLastError();
        //LogInetError(Error, L"HttpOpenRequest");
        return 1;
    }

    if (!HttpSendRequest(hURL, NULL, NULL, NULL, 0))
    {
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "HttpSendRequest %d\n", GetLastError());
        return 1;
    }

    wstring lengthData;
    lengthData.resize(256);
    DWORD QIRead = lengthData.size();
    DWORD index = 0;
    if (!HttpQueryInfo(hURL, HTTP_QUERY_CONTENT_LENGTH, &lengthData[0], &QIRead, &index))
    {
        DWORD lastError = GetLastError ();
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Unable to get the content length (lastError = %d)\n", lastError);

        vector<char> temp;
        temp.resize(QIRead);
        HttpQueryInfo(hURL, HTTP_QUERY_CONTENT_LENGTH, &temp[0], &QIRead, &index);
        return 1;
    }

    DWORD contentLength = _wtoi(lengthData.c_str());

    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Opening file: %ls\nLength: %d bytes\n", sourceName.c_str(), contentLength);
    //printf("Opening file: %ls\nLength: %d bytes\n", sourceName.c_str(), contentLength);

    vector<char> buffer;
    buffer.resize(contentLength + 1);
    DWORD bytesRead = 0;

    BOOL bRead = InternetReadFile(hURL, &buffer[0], buffer.size() - 1, &bytesRead);
    if (!bRead || bytesRead == 0)
    {
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Failed to get the data\n");
        return 1;
    }

    //printf ("%d bytes\n", bytesRead);

    FileHandle hFile (CreateFile(destinationName.c_str(), GENERIC_WRITE, 0, 
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));

    if (!hFile.isValid())
    {
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Unable to open output file\n");
        return 1;
    }

    DWORD bytesWritten = 0;
    if (!WriteFile(hFile, &buffer[0], bytesRead, &bytesWritten, NULL))
    {
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Failed to write the file\n");
        return 1;
    }

    return 0;
}

// Take an input string in hh:mm:ss format and calculate the number
// of 100ns intervals that represents
UINT64 ConvertStringToInt64Time(string const& inputTime)
{
    unsigned int h, m, s;
    sscanf_s(&inputTime[0], "%d:%d:%d", &h, &m, &s);
    
    return static_cast<UINT64>((h * 60 + m) * 60 + s) * oneSecond;
}

// Take an input string in hh:mm:ss format and calculate the number
// of 100ns intervals that represents as of today (local time)
UINT64 ConvertStringToInt64TimeToday(string const& inputTime)
{
    unsigned int h, m, s;
    sscanf_s(&inputTime[0], "%d:%d:%d", &h, &m, &s);
    
    SYSTEMTIME stLocalTime;
    GetLocalTime(&stLocalTime);

    UINT64 systemMinusLocal = internalTime::SystemTimeMinusLocalTime();

    stLocalTime.wHour = static_cast<WORD>(h);
    stLocalTime.wMinute = static_cast<WORD>(m);
    stLocalTime.wSecond = static_cast<WORD>(s);
    stLocalTime.wMilliseconds = 0;

    // Convert the now adjusted time
    internalTime localTime;
    SystemTimeToFileTime(&stLocalTime, localTime.FileTimePtr());

    // localTime[adjusted] + systemMinusLoal = sytemTime[adjusted]
    return localTime + systemMinusLocal;
}

//// Sets the input value to a time in the future
//int FindNextTimeInTheFuture(UINT64& nextTime, UINT64 interval)
//{
//    int skipped = 0;
//
//    UINT64 now = internalTime::Now() + oneSecond / 100;
//
//    if (nextTime <= now)
//    {
//        UINT64 diff = now - nextTime;
//        skipped = static_cast<int>((diff / interval) + 1);
//        nextTime += skipped * interval;
//    }
//
//    return skipped;
//}
//
// Interpret the configuration file
// all lines that start with ';' are comments
// valid lines have the format
// [url] [dest] [hh:mm:ss] [hh:mm:ss]
// where the first [hh:mm:ss] is the time of day to start downloading
// and the second is the amount of time between downloads
vector<queuedFile> ProcessConfig(vector<string> const& validLines)
{
    vector<queuedFile> retv;

    for(vector<string>::const_iterator cit = validLines.begin(); cit < validLines.end(); ++cit)
    {
        queuedFile qf;
        vector<string> fields = ConvertLineToFields(*cit);
    
        if (fields.size() < 4)
        {
            // Malformed line found
            UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "skipping malformed line:\n%s\n", cit->c_str());
            continue;
        }

        // Check to see if the first field is FLIR
        if (fields[0] == "FLIR")
        {
            qf.isFLIR = true;

        }
        else
        {
            // Now just extract the data
            wstring source = StupidConvertToWString(fields[0]);
            URL_COMPONENTS urlParts = { sizeof(URL_COMPONENTS) };
            urlParts.dwHostNameLength = source.length();
            urlParts.dwUrlPathLength = source.length();
            InternetCrackUrl(source.c_str(), 0, 0, &urlParts);
            qf.sourceServer = wstring(urlParts.lpszHostName, urlParts.lpszHostName + urlParts.dwHostNameLength);
            qf.sourceResource = wstring (urlParts.lpszUrlPath, urlParts.lpszUrlPath + urlParts.dwUrlPathLength);

        }

        qf.destinationRootName = StupidConvertToWString(fields[1]);
        qf.startTime = ConvertStringToInt64Time(fields[2]);
        qf.downloadInterval = ConvertStringToInt64Time(fields[3]);
        
        UINT64 now = internalTime::Now();
        
        // If we have a don't care state, for start time use now
        if (qf.startTime == 0)
        {
            qf.startTime = now;
        }
        else
        {
            qf.startTime = ConvertStringToInt64TimeToday(fields[2]);
            FindNextTimeInTheFuture(qf.startTime, qf.downloadInterval);
        }

        if (qf.isFLIR)
        {
            if (fields.size() <= 4)
            {
                UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "skipping malformed line:\n%s\n", cit->c_str());
                continue;
            }

            qf.flatFieldFrameInterval = atoi(fields[4].c_str());
        }
        else if (fields.size() > 4)
        {
            qf.username = StupidConvertToWString(fields[4]);
        }

        if (fields.size() > 5)
        {
            qf.password = StupidConvertToWString(fields[5]);
        }

        retv.push_back(qf);        
    }

    return retv;
}

vector<queuedFile> ReadConfiguration(wstring const& filename)
{
    vector<queuedFile> retv;

    // Read each line
    // if the line begins with a ';' discard it
    // strip out the whitespace at the beginning
    FileHandle hFile = CreateFile(filename.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return retv;
    }

    // We will assume the config file is less than 4GB long.  If you have one that big, the error is yours
    string buffer;
    buffer.resize(GetFileSize(hFile, NULL) + 1);
    buffer[buffer.size()-1] = 0;
    DWORD readLen = 0;
    ReadFile(hFile, &buffer[0], buffer.size()-1, &readLen, NULL);

    vector<string> validLines = ConvertBufferToLines(buffer);

    return ProcessConfig(validLines);
}

// Uses jpg as the extension
void TimeToSubDirectoryAndFilename(SYSTEMTIME st, wstring& subDirectory, wstring& filename, wstring const& ext = L".jpg")
{
    WCHAR buffer[100];
    swprintf_s(buffer, L"\\%04d%02d%02d\\", st.wYear, st.wMonth, st.wDay);
    subDirectory = wstring(buffer);
    swprintf_s(buffer, L"%02d%02d%02d", st.wHour, st.wMinute, st.wSecond);
    filename = wstring(buffer) + ext;
}

// This is the main loop of the program
// It is on its own thread to allow it to be as simple as possible
// The basic idea is a priority queue
// The start times for the next download are all calculated
// These are used as the keys to a map of the elements to be downloaded
// When the first element's time is ready that element is removed from the queue
// The next time for that element is calculated and it is placed back on the queue
// then the information about that element is used to start a download
// One optimization might be to allow multiple threads to wait on elements in the queue
// so as to improve synchronization.
// This will only matter if the download times cause significant differences in the
// output images
int ProcessingLoop(priorityQueue::value_type const* pElement)
{
    priorityQueue pq;
    pq[pElement->first] = pElement->second;
    InternetHandle hInternet (pElement->second.hInternet);   // Take ownership, will call close on exit
    delete pElement;

    while(!quit)
    {
        // Start processing the queue
        priorityQueue::const_iterator head = pq.begin();

        UINT64 currentDownloadTime = head->first;
        queuedFile qf = head->second;
        pq.erase(head);

        // Calculate the next time fo this download
        UINT64 nextQueuedTime = currentDownloadTime + qf.downloadInterval;
        int skipped = FindNextTimeInTheFuture(nextQueuedTime, qf.downloadInterval) - 1;

        if (skipped > 0)
        {
            UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Skipped %d downloads of %ls\n", skipped, (qf.sourceServer + qf.sourceResource).c_str());
        }

        if (nextQueuedTime < internalTime::Now())
        {
            int i = 0;
            i;
        }

        // Don't stomp on existing queued elements
        // This loop can only be as long as the total number of queued elements minus one
        while (pq.find(nextQueuedTime) != pq.end())
        {
            nextQueuedTime += 1;
        }
        pq[nextQueuedTime] = qf;

        // Debug
        //for_each(pq.begin(), pq.end(), PrintPriorityQueueElement);

        while (!quit)
        {
            // Determine if a time has passed
            UINT64 now = internalTime::Now();
            if (displayQueue)
            {
                displayQueue = false;
                //printf ("\nDisplaying current queue\n");
                for_each(pq.begin(), pq.end(), PrintPriorityQueueElement);
            }

            if (currentDownloadTime > now)
            {
                //int seconds = static_cast<int>(static_cast<__int64>(currentDownloadTime - now) / oneSecond);
                //printf("Time to next download: %02d:%02d:%02d\r", seconds / 3600, (seconds / 60) % 60, seconds % 60);
            }
            else
            {
                SYSTEMTIME sysTime;
                GetLocalTime(&sysTime);
                wstring subDirectory, filename;
                TimeToSubDirectoryAndFilename(sysTime, subDirectory, filename, qf.isFLIR ? L".fit" : L".jpg");
                CreateDirectory((qf.destinationRootName + subDirectory).c_str(), NULL);
                wstring fullPathName = qf.destinationRootName + subDirectory + filename;
                //printf(, );
                printf ("Downloading %30ls\n""Writing %ls: \n", (qf.sourceServer + qf.sourceResource).c_str(), fullPathName.c_str());

                if (qf.isFLIR)
                {
                    bool doFlatField = (qf.frames++ % qf.flatFieldFrameInterval) == 0;
                    ReadCamera(fullPathName, doFlatField);
                    pq[nextQueuedTime] = qf;
                }
                else if (ReadWebFile(qf.hInternet, qf.sourceResource, fullPathName) != 0)
                {
                    printf("\n\nLogging: Failure to download\n Source     : %ls\n Destination: %ls\n\n", 
                        (qf.sourceServer + qf.sourceResource).c_str(), fullPathName.c_str());
                }
                break;
            }

            DWORD sleepTime = static_cast<DWORD>((currentDownloadTime - now) / dw100nsPerMS);
            sleepTime = min(sleepTime, maxSleepTime);

            // Sleep up to the max
            Sleep(sleepTime);
        }
    }

    return 0;
}

// Simple forwarding function
void __cdecl ProcessingThread(void* pInput)
{
    priorityQueue::value_type const* pQueuedFile = reinterpret_cast<priorityQueue::value_type const*>(pInput);
    ProcessingLoop(pQueuedFile);
}

//class Logging
//{
//public :
//    Logging()
//    {
//        FILE* pFile;
//        freopen_s(&pFile, "TimedDownload.log", "at+", stderr);
//        for (int i=0;i < 10 && !pFile;++i)
//        {
//            char buffer[] = "TimedDownload0.log";
//            buffer[strlen(buffer) - 5] = static_cast<char>('0' + i);
//            freopen_s(&pFile, buffer, "at+", stderr);
//        }
//
//        SYSTEMTIME localTime;
//        GetLocalTime(&localTime);
//
//        // If the file has been used, put some spaces in here
//        if(ftell(stderr))
//        {
//            UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "\n\n");
//        }
//
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "------------NEW INSTANCE------------\n");
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Date (yyyy/mm/dd): %04d/%02d/%02d\n", localTime.wYear, localTime.wMonth, localTime.wDay);
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Time   (hh:mm:ss):   %02d:%02d:%02d\n", localTime.wHour, localTime.wMinute, localTime.wSecond);
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "------------------------------------\n");
//    }
//
//    ~Logging()
//    {
//        SYSTEMTIME localTime;
//        GetLocalTime(&localTime);
//
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "------------------------------------\n");
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Date (yyyy/mm/dd): %04d/%02d/%02d\n", localTime.wYear, localTime.wMonth, localTime.wDay);
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Time   (hh:mm:ss):   %02d:%02d:%02d\n", localTime.wHour, localTime.wMinute, localTime.wSecond);
//        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "------------NORMAL EXIT-------------\n");
//    }
//};
//
//
class StartImageThread
{    
public :
    void operator() (priorityQueue::value_type const& qfPair)
    {
        // ProcessingThread responsible for deleting
        // priority queue element
        m_handles.push_back(reinterpret_cast<HANDLE>(
            _beginthread(ProcessingThread, 0, 
            new priorityQueue::value_type(qfPair))));
    }

    vector<HANDLE> m_handles;
};

struct InterpretConfigFile
{
    InterpretConfigFile(vector<queuedFile>& queuedFiles)
        : m_pQueuedFiles(&queuedFiles)
    {
    }

    unsigned operator ()(vector<string> const& input)
    {
        *m_pQueuedFiles = ProcessConfig(input);
        return m_pQueuedFiles->size();
    }

    vector<queuedFile>* m_pQueuedFiles;
};

// The entry point
// Check for a valid internet connection
// Interpret the configuration file
// Create the priority queue for downloads
// Start the thread to do the downloads
// Wait for the user to quit
int _tmain(int argc, _TCHAR* argv[])
{
    //Logging setupLog;

    Internet iNetConnection(L"TimedDownload");
    if (!iNetConnection.isValid())
    {
        printf ("Unable to open an internet connection - no functionality can be expected\nExiting\n");
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Unable to open an internet connection - no functionality can be expected\nExiting\n");

        return 1;
    }

    vector<queuedFile> sources;
    InterpretConfigFile icf(sources);
    ConfigFileReader::ReadConfiguration(argc, argv, icf);

    // Add each line to the queue
    vector<queuedFile>::const_iterator cit = sources.begin();
    priorityQueue pq;
    unsigned i = 0;
    for(;cit != sources.end(); ++cit, ++i)
    {
        // Create the root directory
        CreateDirectory(cit->destinationRootName.c_str(), NULL);

        // bias to minimize conflicts
        pq[cit->startTime + i] = *cit;

        // Skip the setup for files
        if (cit->isFLIR)
        {
            continue;
        }

        WCHAR const* pUsername = NULL;
        WCHAR const* pPassword = NULL;

        // If a username or password exists, open the website
        if (cit->password.length() > 0 || cit->username.length() > 0)
        {
            pUsername = cit->username.c_str();
            pPassword = cit->password.c_str();
        }
        
        printf("Opening internet connection to: %ls\n", cit->sourceServer.c_str());
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Opening internet connection to: %ls\n", cit->sourceServer.c_str());

        // NOTE, we are not parsing the input, so HTTP is all you get
        HINTERNET hConnection = InternetConnect(iNetConnection, 
            cit->sourceServer.c_str(), INTERNET_DEFAULT_HTTP_PORT, 
            pUsername, pPassword, INTERNET_SERVICE_HTTP, 0, 
            reinterpret_cast<DWORD_PTR>(&iNetConnection));
        if (hConnection == NULL)
        {
            UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "InternetConnect Failed %d", GetLastError());
            DWORD error = 0;
            WCHAR buffer[1024];
            DWORD length = _countof(buffer);
            InternetGetLastResponseInfo(&error, buffer, &length);
            UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "%s\n", buffer);
        }

        pq[cit->startTime + i].hInternet = hConnection;
    }

    // Print out our interpretation of the input file:
    UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Configuration file interpretation:\n");
    for_each(pq.begin(), pq.end(), PrintPriorityQueueElement);
    
    StartImageThread threads = for_each(pq.begin(), pq.end(), StartImageThread());
    if (threads.m_handles.size() == 0)
    {
        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "No threads started, nothing to do, exiting\n");
        printf("No threads started, nothing to do, exiting\n");
        return 1;
    }

    SetConsoleTitle(L"TimedDownload - Press Q or ESC to exit");

    while (!quit)
    {
        int c = _getch();
        if (c == VK_ESCAPE || c == 'q' || c == 'Q')
        {
            quit = true;
        }
        
        // Check for f2
        if(c == 0)
        {
            c = _getch();
            if(c == 60)
            {
                displayQueue = true;
            }
        }
    }

    printf ("\nWaiting on threads to die\n");
    WaitForMultipleObjects(threads.m_handles.size(), &threads.m_handles[0], true, INFINITE);
}

