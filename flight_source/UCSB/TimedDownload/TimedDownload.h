#pragma once
// TimedDownload.h
//
// This was generated by Russell Woods
// 
// Original Compiler
// Microsoft Visual Studio 2008
// Version 9.0.21022.8 RTM



#include <algorithm>
#include <map>
#include <string>
#include <vector>
#include <conio.h>
#include <stdio.h>

#include <process.h>
#include <Wininet.h>
#pragma comment (lib, "Wininet")
#include "utility.h"

// A simple, and simpleminded template class to ensure that handles are automatically closed
// DO NOT call the explicit close function or the OS may reject the automatic version
// These do not have copy constructors - that's a feature, not a bug
// copying these objects would result in double closeFn calls
// If you think this needs to be copyable, then you need to write
// a reference counting system
template <typename HANDLETYPE, HANDLETYPE invalidValue, typename CloseFnType, CloseFnType CloseFn>
class AutoCloseHandle
{
public :
    AutoCloseHandle(HANDLETYPE h) : m_handle(h)
    {
        if (h == invalidValue)
        {
            // Could throw here
        }
    }

    virtual ~AutoCloseHandle() 
    {
        if (m_handle != invalidValue)
        {
            CloseFn (m_handle);
        }
    }

    operator HANDLETYPE() const { return m_handle; }

    bool isValid()
    {
        return m_handle != invalidValue;
    }

private :
    AutoCloseHandle(AutoCloseHandle const&);
    AutoCloseHandle& operator = (AutoCloseHandle const&);

    HANDLETYPE  m_handle;
};

// Uses of the above class
typedef AutoCloseHandle<HANDLE, INVALID_HANDLE_VALUE, BOOL(WINAPI *)(HANDLE), CloseHandle>  FileHandle;
typedef AutoCloseHandle<HINTERNET, 0, BOOL(WINAPI *)(HINTERNET), InternetCloseHandle>       InternetHandle;

// This is probably a useless class
// I thought there would be more here, there isn't
// it just uses the AutoCloseHandle class and sets the handle based on
// calling InternetOpen
class Internet : public InternetHandle
{
public :
    Internet(std::wstring const& name) : InternetHandle(
        InternetOpen(name.c_str(), 
        INTERNET_OPEN_TYPE_PRECONFIG, 
        NULL, 
        L"<local>", 0))
    {
        if (isValid())
        {
            InternetSetStatusCallback(this->operator HINTERNET(), InternetStatusCallback);
        }
    }

private :
    // Prevent copying
    Internet(Internet const&);
    Internet& operator = (Internet const&);

    static void CALLBACK InternetStatusCallback(
      __in  HINTERNET , //hInternet,
      __in  DWORD_PTR , // dwContext,
      __in  DWORD dwInternetStatus,
      __in  LPVOID , //lpvStatusInformation,
      __in  DWORD // dwStatusInformationLength
    )
    {
        struct StatusName
        {
            char const* pName;
            DWORD       id;
        };

        StatusName statusName[] = 
        {
            "INTERNET_STATUS_RESOLVING_NAME", 10,
            "INTERNET_STATUS_NAME_RESOLVED", 11,
            "INTERNET_STATUS_CONNECTING_TO_SERVER", 20,
            "INTERNET_STATUS_CONNECTED_TO_SERVER", 21,
            "INTERNET_STATUS_SENDING_REQUEST", 30,
            "INTERNET_STATUS_REQUEST_SENT", 31,
            "INTERNET_STATUS_RECEIVING_RESPONSE", 40,
            "INTERNET_STATUS_RESPONSE_RECEIVED", 41,
            "INTERNET_STATUS_CTL_RESPONSE_RECEIVED", 42,
            "INTERNET_STATUS_PREFETCH", 43,
            "INTERNET_STATUS_CLOSING_CONNECTION", 50,
            "INTERNET_STATUS_CONNECTION_CLOSED", 51,
            "INTERNET_STATUS_HANDLE_CREATED", 60,
            "INTERNET_STATUS_HANDLE_CLOSING", 70,
            "INTERNET_STATUS_DETECTING_PROXY", 80,
            "INTERNET_STATUS_REQUEST_COMPLETE", 100,
            "INTERNET_STATUS_REDIRECT", 110,
            "INTERNET_STATUS_INTERMEDIATE_RESPONSE", 120,
            "INTERNET_STATUS_USER_INPUT_REQUIRED", 140,
            "INTERNET_STATUS_STATE_CHANGE", 200,
            "INTERNET_STATUS_COOKIE_SENT", 320,
            "INTERNET_STATUS_COOKIE_RECEIVED", 321,
            "INTERNET_STATUS_PRIVACY_IMPACTED", 324,
            "INTERNET_STATUS_P3P_HEADER", 325,
            "INTERNET_STATUS_P3P_POLICYREF", 326,
            "INTERNET_STATUS_COOKIE_HISTORY", 327,
        };

        char const* pName = "Unknown status code\n";
        for (int i=0; i <sizeof(statusName) / sizeof(statusName[0]); ++i)
        {
            if (dwInternetStatus == statusName[i].id)
            {
                pName = statusName[i].pName;
                break;
            }
        }

        UCSBUtility::LogError(__FUNCTION__, __FILE__, __LINE__, "Status Callback\nStatus: %s\nStatus Code: %d\n", pName, dwInternetStatus);
    }

};

// Structure to hold the elements queued for download
struct queuedFile
{
    std::wstring    sourceServer;
    std::wstring    sourceResource;
    std::wstring    destinationRootName;
    bool            isFLIR;
    size_t          flatFieldFrameInterval;
    size_t          frames;
    UINT64          downloadInterval;
    UINT64          startTime;
    std::wstring    username;               // These SHOULD be secure
    std::wstring    password;               // They are NOT.  Do NOT USE this for consumer code
                                            // In fact, use this as an example of how NOT to write
                                            // real code.
    HINTERNET       hInternet;              // Handle to the internet connection used for this download

    queuedFile()
        : hInternet(NULL)
        , downloadInterval(0)
        , startTime(0)
        , isFLIR(false)
        , flatFieldFrameInterval(1)
        , frames(0)
    {
    }
};

typedef std::map<__int64, queuedFile>   priorityQueue;


